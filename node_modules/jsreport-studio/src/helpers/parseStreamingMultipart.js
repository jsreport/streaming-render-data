const PARAM_REGEXP = /;[\x09\x20]*([!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*=[\x09\x20]*("(?:[\x20!\x23-\x5b\x5d-\x7e\x80-\xff]|\\[\x20-\x7e])*"|[!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*/g
const DISPOSITION_TYPE_REGEXP = /^([!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*(?:$|;)/
const QESC_REGEXP = /\\([\u0000-\u007f])/g

async function parseStreamingMultipart (response, onFile) {
  const contentType = response.headers.get('Content-Type')
  const boundary = getBoundary(contentType)

  const reader = response.body.getReader()
  const textDecoder = new TextDecoder()

  const patchResolver = new FileResolver({
    onResponse: (partsFound) => {
      for (let i = 0; i < partsFound.length; i++) {
        try {
          onFile(partsFound[i])
        } catch (e) {
          console.error(`Error during onFile callback of "${partsFound[i].name}" entry`, e)
        }
      }
    },
    boundary
  })

  return reader.read().then(function sendNext({ value, done }) {
    if (done) {
      return
    }

    let plaintext

    try {
      plaintext = textDecoder.decode(value)
      // Read the header to get the Content-Length
      patchResolver.handleChunk(plaintext)
    } catch (err) {
      const parseError = new Error(`Parsing error. ${err.message}`)
      parseError.stack = err.stack
      parseError.rawText = plaintext
      throw parseError
    }

    return reader.read().then(sendNext)
  })
}

export default parseStreamingMultipart

class FileResolver {
  constructor ({ onResponse, boundary }) {
    this.boundary = boundary
    this.onResponse = onResponse
    this.processedChunks = 0
    this.chunkBuffer = ''
  }

  handleChunk (data) {
    this.chunkBuffer += data

    const { newBuffer, parts } = parseMultipartHttp(this.chunkBuffer, this.boundary)

    this.chunkBuffer = newBuffer

    if (parts.length > 0) {
      this.onResponse(parts)
    }
  }
}

function getBoundary (contentType = '') {
  const contentTypeParts = contentType.split(';')

  for (const contentTypePart of contentTypeParts) {
    const [key, value] = (contentTypePart || '').trim().split('=')

    if (key === 'boundary' && !!value) {
      if (value[0] === '"' && value[value.length - 1] === '"') {
        return value.substr(1, value.length - 2)
      }

      return value
    }
  }

  return '-'
}

function parseMultipartHttp (buffer, boundary, previousParts = []) {
  const delimeter = getDelimiter(boundary)
  let [, rest] = splitWithRest(buffer, delimeter)

  if (rest == null || rest.length === 0) {
    // we did not finish receiving the initial delimeter
    return {
      newBuffer: buffer,
      parts: previousParts,
    }
  }

  const parts = splitWithRest(rest, '\r\n\r\n')
  const headers = parts[0]

  rest = parts[1]

  if (rest == null || rest.length === 0) {
    // we did not finish receiving the headers
    return {
      newBuffer: buffer,
      parts: previousParts,
    }
  }

  const parsedHeaders = parseHeaders(headers)

  const contentLengthHeader = parsedHeaders['content-length']

  if (contentLengthHeader === undefined) {
    throw new Error('Invalid MultiPart Response, no content-length header')
  }

  const contentLength = parseInt(contentLengthHeader, 10)

  if (isNaN(contentLength)) {
    throw new Error('Invalid MultiPart Response, could not parse content-length')
  }

  // Strip out the final delimiter
  const finalDelimeter = getFinalDelimiter(boundary)

  rest = rest.replace(finalDelimeter, '')

  const uint = new TextEncoder().encode(rest)

  if (uint.length < contentLength) {
    // still waiting for more body to be sent
    return {
      newBuffer: buffer,
      parts: previousParts
    }
  }

  const bodyBuf = uint.subarray(0, contentLength)
  const nextBuffer = new TextDecoder().decode(uint.subarray(contentLength))

  const contentDisposition = parsedHeaders['content-disposition']
  const [contentDispositionType, contentDispositionParams] = parseContentDisposition(contentDisposition)

  const part = {
    name: contentDispositionParams.name,
    filename: contentDispositionParams.filename,
    contentDispositionType: contentDispositionType,
    contentType: parsedHeaders['content-type'],
    headers: parseHeaders,
    rawData: bodyBuf
  }

  const newParts = [...previousParts, part]

  if (nextBuffer.length > 0) {
    return parseMultipartHttp(nextBuffer, boundary, newParts)
  }

  return { parts: newParts, newBuffer: '' }
}

function parseHeaders (headers) {
  const result = {}
  const headersArr = headers.split('\r\n')

  for (let i = 0; i < headersArr.length; i++) {
    const row = headersArr[i]
    const index = row.indexOf(':')
    const key = trim(row.slice(0, index)).toLowerCase()
    const value = trim(row.slice(index + 1))

    if (typeof(result[key]) === 'undefined') {
      result[key] = value
    } else if (isArray(result[key])) {
      result[key].push(value)
    } else {
      result[key] = [result[key], value]
    }
  }

  return result
}

function parseContentDisposition (string) {
  if (!string || typeof string !== 'string') {
    throw new TypeError('argument string is required')
  }

  let match = DISPOSITION_TYPE_REGEXP.exec(string)

  if (!match) {
    throw new TypeError('invalid type format')
  }

  // normalize type
  let index = match[0].length
  const type = match[1].toLowerCase()

  let key
  let names = []
  let params = {}
  let value

  // calculate index to start at
  index = PARAM_REGEXP.lastIndex = match[0].substr(-1) === ';' ? index - 1 : index

  // match parameters
  while ((match = PARAM_REGEXP.exec(string))) {
    if (match.index !== index) {
      throw new TypeError('invalid parameter format')
    }

    index += match[0].length
    key = match[1].toLowerCase()
    value = match[2]

    if (names.indexOf(key) !== -1) {
      throw new TypeError('invalid duplicate parameter')
    }

    names.push(key)

    if (key.indexOf('*') + 1 === key.length) {
      // decode extended value
      throw new Error('Content-Disposition value not supported')
    }

    if (typeof params[key] === 'string') {
      continue
    }

    if (value[0] === '"') {
      // remove quotes and escapes
      value = value
        .substr(1, value.length - 2)
        .replace(QESC_REGEXP, '$1')
    }

    params[key] = value
  }

  if (index !== -1 && index !== string.length) {
    throw new TypeError('invalid parameter format')
  }

  return [type, params]
}

function trim (string) {
  return string.replace(/^\s+|\s+$/g, '')
}

function getDelimiter (boundary) {
  return `\r\n--${boundary}\r\n`
}

function getFinalDelimiter (boundary) {
  return `\r\n--${boundary}--\r\n`
}

function splitWithRest (string, delim) {
  const index = string.indexOf(delim)

  if (index < 0) {
    return [string]
  }

  return [string.substring(0, index), string.substring(index + delim.length)]
}
