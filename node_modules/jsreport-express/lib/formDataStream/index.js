const path = require('path')
const { Readable } = require('stream')
const mime = require('mime-types')
const MultiStream = require('./multistream')

class FormData extends MultiStream {
  #fields
  #multiStreamFactoryCallback
  #timerRef
  #consumed
  #ended
  #queue
  #boundary
  #error

  static LINE_BREAK = '\r\n'
  static DEFAULT_CONTENT_TYPE = 'application/octet-stream'

  constructor(options = {}) {
    let factoryCallback

    const factory = (cb) => {
      if (!factoryCallback) {
        factoryCallback = cb
      } else {
        this.#multiStreamFactoryCallback = cb
      }
    }

    super(factory, { ...options, autoEnd: false })

    this.#fields = []
    this.#queue = []
    this.#ended = false
    this.#consumed = false
    this.#multiStreamFactoryCallback = factoryCallback

    this.once('error', (err) => {
      clearImmediate(self.#timerRef)
    })

    this.once('end', () => {
      this.#consumed = true
    })

    const self = this

    this.#timerRef = setImmediate(function checkIfEnded() {
      if (self.#consumed) {
        return
      }

      self.#flushQueue()

      self.#timerRef = setImmediate(checkIfEnded)
    })
  }

  getBoundary () {
    if (!this.#boundary) {
      this.#boundary = generateBoundary()
    }

    return this.#boundary
  }

  setBoundary (boundary) {
    this.#boundary = boundary
  }

  append (field, value, options = {}) {
    if (this.#ended) {
      return
    }

    // allow filename as single option
    if (typeof options == 'string') {
      options = { filename: options }
    }

    // all that streamy business can't handle numbers
    if (
      typeof value == 'number' ||
      typeof value === 'boolean' ||
      typeof value === 'undefined' ||
      value === null
    ) {
      value = '' + value
    }

    if (Array.isArray(value)) {
      // Please convert your array into string
      // the way web server expects it
      this.#emitError(new Error('Arrays are not supported.'))
      return
    }

    if (typeof value === 'string' || Buffer.isBuffer(value)) {
      options.contentLength = typeof value === 'string' ? Buffer.byteLength(value) : value.length
    }

    if (this.#fields.length === 0) {
      this.#addToReadableQueue(FormData.LINE_BREAK)
    }

    this.#fields.push(field)

    const header = this.#multiPartHeader(field, value, options)
    const footer = this.#multiPartFooter()

    this.#addToReadableQueue(header)
    this.#addToReadableQueue(value)
    this.#addToReadableQueue(footer)
  }

  end () {
    // add the last boundary
    this.#ended = true
    this.#addToReadableQueue(this.#lastBoundary())

    this.#flushQueue(() => {
      this.push(null)
      this.destroy()
    })
  }

  toString () {
    return '[object FormData]'
  }

  #multiPartHeader (field, value, options) {
    // custom header specified (as string)?
    // it becomes responsible for boundary
    // (e.g. to handle extra CRLFs on .NET servers)
    if (typeof options.header == 'string') {
      return options.header
    }

    const contentDisposition = getContentDisposition(value, options)
    const contentType = getContentType(value, options)

    let contents = ''

    const headers  = {
      // add custom disposition as third element or keep it two elements if not
      'Content-Disposition': ['form-data', 'name="' + field + '"'].concat(contentDisposition || []),
      // if no content type. allow it to be empty array
      'Content-Type': [].concat(contentType || [])
    }

    if (options.contentLength != null) {
      headers['Content-Length'] = options.contentLength
    }

    // allow custom headers.
    if (typeof options.header == 'object') {
      populate(headers, options.header)
    }

    let header

    for (let prop in headers) {
      if (!headers.hasOwnProperty(prop)) {
        continue
      }

      header = headers[prop]

      // skip nullish headers.
      if (header == null) {
        continue
      }

      // convert all headers to arrays.
      if (!Array.isArray(header)) {
        header = [header]
      }

      // add non-empty headers.
      if (header.length) {
        contents += prop + ': ' + header.join('; ') + FormData.LINE_BREAK
      }
    }

    return `--${this.getBoundary()}${FormData.LINE_BREAK}${contents}${FormData.LINE_BREAK}`
  }

  #multiPartFooter () {
    return FormData.LINE_BREAK
  }

  #lastBoundary () {
    return `--${this.getBoundary()}--${FormData.LINE_BREAK}`
  }

  #flushQueue (endCb) {
    const streams = []

    while (this.#queue.length > 0) {
      const item = this.#queue.shift()

      if (typeof item === 'function') {
        streams.push(item)
      } else {
        streams.push(() => {
          item.resume()
          return item
        })
      }
    }

    if (streams.length > 0) {
      const combined = new MultiStream(streams)

      if (endCb) {
        combined.on('end', () => endCb())
      }

      this.#multiStreamFactoryCallback(null, combined)
    }
  }

  #addToReadableQueue (value) {
    let stream

    if (typeof value === 'string' || Buffer.isBuffer(value)) {
      stream = Readable.from(typeof value === 'string' ? [value] : value, {
        objectMode: false
      })
    } else {
      stream = value
    }

    if (typeof value !== 'function') {
      stream.pause()
    }

    this.#queue.push(stream)
  }

  #emitError (err) {
    if (!this.#error) {
      this.#error = err
      this.pause()
      this.emit('error', err)
    }
  }
}

module.exports = FormData

function populate (dst, src) {
  Object.keys(src).forEach((prop) => {
    dst[prop] = dst[prop] || src[prop]
  })

  return dst
}

function generateBoundary () {
  // This generates a 50 character boundary similar to those used by Firefox.
  // They are optimized for boyer-moore parsing.
  let boundary = '--------------------------'

  for (let i = 0; i < 24; i++) {
    boundary += Math.floor(Math.random() * 10).toString(16)
  }

  return boundary
}

function getContentDisposition (value, options) {
  let filename
  let contentDisposition

  if (typeof options.filepath === 'string') {
    // custom filepath for relative paths
    filename = path.normalize(options.filepath).replace(/\\/g, '/')
  } else if (options.filename || value.name || value.path) {
    // custom filename take precedence
    // formidable and the browser add a name property
    // fs- and request- streams have path property
    filename = path.basename(options.filename || value.name || value.path)
  } else if (value.readable && value.hasOwnProperty('httpVersion')) {
    // or try http response
    filename = path.basename(value.client._httpMessage.path || '')
  }

  if (filename) {
    contentDisposition = `filename="${filename}"`
  }

  return contentDisposition
}

function getContentType (value, options) {
  // use custom content-type above all
  let contentType = options.contentType

  // or try `name` from formidable, browser
  if (!contentType && value.name) {
    contentType = mime.lookup(value.name)
  }

  // or try `path` from fs-, request- streams
  if (!contentType && value.path) {
    contentType = mime.lookup(value.path)
  }

  // or if it's http-reponse
  if (!contentType && value.readable && value.hasOwnProperty('httpVersion')) {
    contentType = value.headers['content-type']
  }

  // or guess it from the filepath or filename
  if (!contentType && (options.filepath || options.filename)) {
    contentType = mime.lookup(options.filepath || options.filename)
  }

  // fallback to the default content type if `value` is not simple value
  if (!contentType && typeof value == 'object') {
    contentType = FormData.DEFAULT_CONTENT_TYPE
  }

  return contentType
}
